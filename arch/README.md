# 架构说明

总体来说，Nanovm会依照JVM进行设计，并且使用jvm字节码的一个子集。  
不过，我们并不想做一个完整的JVM，只是利用已有的规范而已。

## 模块划分

Nanovm分为如下模块:

VM层

1. Code manager: 将字节码读入内存，并管理方法区
2. Stack manager: 从方法区获取字节码，并管理栈帧以及局部变量
3. Memory manager: 管理对象的生命周期。Nanovm只使用引用计数做gc
4. Native mapper: 定义c和客户的代码的交互数据结构，并将客户端方法映射到native方法

SDK层

1. nanovm.string: 字符串类型，和java干的不一样，全部使用native方法，直接封装到底层去处理
2. nanovm.syscall: 系统调用函数，类型系统保护的api仅提供可跨平台的选项，但提供扩展点可以设置
3. nanovm.console: 控制台输入输出相关
4. nanovm.os: 操作系统相关，例如线程等
5. nanovm.lang: 语言扩展，例如free函数

## 简易图示

```
BYTECODE{CAFEBABE...}
       |                 +-----------------+       +------------------------------+
       |                 |   Code manager  |       |       Stack manager          |
       |                 | +-----+ +-----+ |       | +--------------------------+ |
       +------------------>|class| |class| |       | |          Stack           | |
                         | |field| |field| |       | | +----------------------+ | |
                         | |meth | |meth -----+------------->   Frame         | | |
                         | +-----+ +-----+ |  |    | | | +--------+ +-------+ | | |
                         +-----------------+  |    | | | |opstack | | vars  | | | |
                                              |    | | | +--------+ +-------+ | | |
                                              |    | | +----------------------+ | |
       +-----------------------------------+  |    | +--------------------------+ |
       |                                   |  |    +------------------------------+
       |                                   |  |
       |           Memory manager          |  |
       |     controls all allocations      |  |
       |                                   |  |    +------------------------+
       |                                   |  +--->|     Native manager     |
       +-----------------------------------+       +------------------------+

```

## 主流程样例

主函数：

1. （外部)使用SDK编写java代码
1. （外部)javac编译
1. code-manager全量读取字节码，转换为class_t结构体
1. stack-manager创建主线程调用栈
1. stack-manager创建栈帧
1. stack-manager在栈帧里面创建操作数栈
1. native-mapper将入参(char[][])转换为客户端数据结构(nanovm.string[])
1. code-manager寻找指定的Main函数
1. stack-manager将参数放入局部变量表0位置
1. stack-manager从code段开头开始读取指令，并做对应处理

函数调用：

1. stack-manager依次构造各参数对象并入操作数栈（依照jvm指令集，先构造参数对象，再找方法）
1. code-manager寻找指定方法
1. stack-manager创建栈帧
1. stack-manager在栈帧里面创建操作数栈
1. stack-manager在上一栈帧的操作数栈里pop出对象，并放入新栈帧的局部变量表里
1. 调用结束后，stack-manager拿到新函数的返回值，push到老函数操作数栈里
1. stack-manager pop出新函数栈帧

新建对象：

1. memory-manager规划一块内存并返回，该内存包括引用计数和对象需要占用的内存

引用计数增删：

1. 局部变量表清空/覆盖时，原先的非空对象计数-1
1. 操作数栈pop/清空时，对应非空对象计数-1
1. 一个对象被释放时，其内部所指向所有对象计数各-1
1. 栈帧pop时，局部变量表和操作数栈清空，引起引用计数减少
1. 插入局部变量表时，插入对象计数+1
1. push操作数栈时，该非空对象计数+1
1. 对象被赋给字段时，该对象计数+1

* 注：所有申请与释放内存的地方都会向memory-manager发起调用，具体来说，就是申请某个类型的内存，或者归还某个类型的内存。归还内存时，里面未归还的对象将被一并归还
